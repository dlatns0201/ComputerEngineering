# 프로세스 관리
1. [프로세스 문맥](#Process-Context)
2. [Context Switch](#Context-Switch)
3. [스케쥴러](#scheduler)
4. [프로세스 생성](#프로세스-생성)
5. [프로세스 통신](#프로세스-통신)
   

## Process Context
### 정의
- 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보
- CPU는 시분할 시스템 환경에서 타이머 인터럽트로 다른 프로세스에게 제어권을 넘겨줘야 한다.
- 그래서 프로세스의 주소공간(Code, Data, Stack)과 레지스터 값, 커널에 수행되어온 일의 상태, 커널이 관리하고 있는 정보(PCB)를 포함해 저장해둔다.

### Context의 종류
1. Hardware Context: CPU수행 상태를 나타낸 것, PC값과 각 종 레지스터의 저장값을 의미
2. Process address space: 프로세스만의 독자적인 주소공간
3. Kernel Context: PCB와 커널 스택

### PCB
**OS가 시스템 내에서 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널내의 자료구조**
1. 프로세스 상태: CPU할당 가능 여부
2. Program Counter값: 다음에 수행할 명령의 위치
3. CPU Register값: 현 시점에서 레지스터에 저장되어 있는 값
4. CPU Scheduling Information
5. Memory Management Information
6. Resource Usage Information: 사용자에게 자원 사용율을 계산해 알려주는 용도
7. I/O 상태 정보

## Context Switch
### 정의
- 실행할 프로세스를 변경하기 위해 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

CPU Dispatch: Ready상태 프로세스들 중 CPU를 할당 받을 프로세스를 선택 후 CPU제어권을 넘겨받는 과정

프로세스가 I/O 요청을 하는 경우__
1. I/O 요청을 한 프로세스가 실행 상태에서 Wait상태가 된다.
2. CPU를 반환하고 디스크 I/O 서비스를 기다리는 Device queue에 추가된다.
3. 다른 Ready상태의 프로세스가 CPU Dispatch된다.
4. Device queue에서 자기 차례가 되어 I/O서비스를 하거나 받아 Controller가 CPU에게 인터럽트를 발생 시킴
5. 인터럽트를 인지한 CPU는 커널모드로 인터럽트 루틴을 실행하면서 Device queue에서 Ready queue로 빼낸다.
6. 프로세스 상태를 Ready로 바꾸어 주고 로컬 버퍼의 내용을 메모리로 이동시킴
7. 다시 CPU가 사용자 모드가 되고, 인터럽트 루틴을 실행하기 전에 수행했던 프로세스나 방금 Ready queue에 들어간 프로세스 중 우선 순위가 높은 프로세스에게 CPU제어권이 돌아간다 -> 스케쥴링마다 다름

Context Switch란 다른 프로세스로 CPU제어권이 이양되는 과정이지만 프로세스가 System call이나 인터럽트 발생으로 OS커널의 코드를 실행하는 과정 속에서 Process Context일부를 PCB에 저장하지만 Context Switch라고 부르지 않음<br>
-> 하나의 프로세스가 사용자 모드에서 커널 모드로 바뀌는 것일뿐 CPU를 점유하는 프로세스 대상이 바뀌는게 아니기 때문이다.

Context Switch는 많은 Overhead가 따른다. 따라서 타이머에 CPU할당시간을 너무 작게 세팅하면 좋지 않다.

## Scheduler

**어떤 프로세스에게 자원을 할당할지 결정하는 OS커널의 모듈**

### 종류
#### 1. Long Term Scheduler(장기 스케줄러)
- Job Scheduler라고도 함
- 어떤 프로세스를 Ready queue에 넣을지 결정함
- 프로세스에게 메모리를 할당하는 문제를 관여하며 메모리에 동시에 올라간 프로세스의 수를 조절한다.
- New상태의 프로세스를 Ready상태로 만들지도 관여함
- 가끔 호출되기 때문에, 속도가 느린것이 허용된다.
- 시분할 시스템을 사용하는 근래 OS엔 사용하지 않는게 대부분이다.

#### 2.Short Term Scheduler(단기 스케줄러)
- Ready프로세스 중 어떤 프로세스를 실행 상태로 만들지 결정한다.
- 시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출됨
- 빈번하게 호출되기 때문에 수행속도가 빨라야 한다.

#### 3.Medium Term Scheduler
- 메모리 용량이 많아진 현대에는 장기 스케줄러를 사용하지 않는다.
- 많은 프로세스가 메모리를 할당할 경우 시스템 성능 저하를 해결하기 위해 메모리에 적재된 프로세스 수를 동적으로 조절한다.
- 일부 프로세스를 메모리에서 디스크로 Swaqp out하는 역할을 한다.
- Swap out의 0순위 프로세스는 Wait상태의 프로세스들이다 -> 당장 cpu를 획득할 가능성이 없기 때문
- 그래도 공간이 부족할 경우 타이머 인터럽트가 발생해 Ready queue로 이동한 프로세스를 추가적으로 시행한다.
- 이 스케줄러 덕분에 Stopped이라는 프로세스 상태가 추가됨 -> 프로세스를 외부에서 재개하지 않는 이상 다시 활성화 될 수 없음
- 이 스케줄러로 디스크에 Swap out된 프로세스 상태는 Stopped이 된다.

## 프로세스 생성

### 자식 프로세스의 자원 획득법
1. OS에게 직접 할당 받음
2. 부모 프로세스에게 자원을 공유 받음

### 부모 프로세스의 종류
1. 자식 프로세스와 공존하면서 CPU획득을 경쟁한다.
2. 자식 프로세스가 종료될때까지 부모 프로세스가 Wait상태로 존재한다.
    - ex) D-Dos에서 커맨들들 입력하면 종료할 때 까지 프롬프트를 다시 띄우지 않는다.

### 프로세스의 생성
- 유닉스의 Folk System Call은 PID를 제외한 커널내의 정보와 주소 공간 정보를 그대로 복사한다.
- 주소 공간을 따로 갖지만 동일한 내용을 가지고 시작하며, exec 시스템콜로 새로운 프로그램으로 주소 공간을 덮어 쓸 수 있다.

### 프로세스의 종료 방법:
1. 자발적 종료 
    - 프로세스가 마지막 명령을 수행한 뒤 OS에게 알리는 것
    - exit() System Call로 종료를 알림 -> OS가 자원을 회수하고 시스템 내에서 프로세스를 정리한다.
    - exit함수를 명시적으로 호출하지 않아도 컴파일러가 자동으로 삽입해 종료직전에 호출한다.

2. 비자발적 종료
    - 부모 프로세스가 자식 프로세스 수행을 강제로 종료 시킴, abort() 시스템콜 사용
    - 필요한 시기
        - 자식 프로세스가 할당 자원의 한계치를 넘는 경우
        - 자식 프로세스의 작업이 필요없을 때
        - 부모 프로세스가 종료되고 싶을 때

## 프로세스 통신

### 부모-자식 프로세스의 상호 소통
- folk함수의 반환값으로 부모 프로세스는 자식 프로세스의 PID를 받고 자식 프로세스는 0을 받는다.
- 자식 프로세스를 생성하면 사실상 부모 프로세스와는 독립적인 관계가 된다.
- 하지만 독립적인 프로세스들이 서로 협력을 해 처리 속도를 향상 시킬 수 있게 OS에서 프로세스간 협력 매커니즘 IPC를 제공한다.
- IPC를 사용할 때 데이터의 불 일치를 막기 위해 프로세스간의 동기화가 필요하다.

### IPC
- inter Process Communication
공유 변수를 사용하냐 마냐 차이로 두가지로 분류된다.
#### Message Passing: 
- 프로세스간 공유 변수를 사용하지 않고 메세지를 주고 받는 형식
- 두 프로세스간 주소 공간이 달라 커널이 대신 전달해줌

전송 대상에 따라 두가지로 나뉨

- Direct Communication: 
    - 다른 프로세스에게 직접 메세지가 전송됨
    - 상대 프로세스의 이름을 명시적으로 표현함
    - send(P, Message), receive(Q, Message)
    - 이 때, 통신 링크는 자동적으로 생성되며 하나의 링크는 한 쌍마다 할당
- Indirect Communication:
    - 메일 박스라는 저장 공간에 메세지를 전송함
    - 메세지를 Mail box나 Port로부터 전달 받음
    - Mail box마다 고유의 ID를 가짐
    - 하나의 링크가 여러 프로세스들에게 할당될 수 있다.
    - send(A, Message), receive(A, Message)처럼 대상을 mail box이름을 한다.

Direct, Indirect는 연산의 인터페이스가 차이날 뿐, 내부적인 구현 방식은 커널의 중재에 의해 사실상 동일한 방식

2. Shared Memory: 
- 프로세스들이 주소 공간 일부를 공유한다.
- OS가 제공하는 공유 메모리 System Call을 사용해 주소 공간 중 일부를 공유한다.
- 데이터 일관성을 커널이 책임지지 않기에 프로세스들끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 한다.