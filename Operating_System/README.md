# Operating System
___운영 체제와 정보 기술의 원리 정리중입니다.___

01. [ 컴퓨터와 정보 기술의 역사 ](#컴퓨터와-정보-기술의-역사)
    1. [컴퓨터의 선사 시대](#컴퓨터의-선사-시대)
    2. [근대 컴퓨터](#근대-컴퓨터)
    3. [현대 컴퓨터](#현대-컴퓨터)
02. [ 운영 체제 개요](#운영-체제-개요)
    1. [운영 체제란?](#운영-체제란)
    2. [운영 체제의 역할](#운영-체제의-역할)
    3. [운영 체제의 분류](#운영-체제의-분류)
    4. [운영 체제의 자원 관리 기능](#운영-체제의-자원-관리-기능)
03. [컴퓨터 시스템의 동작 원리](#컴퓨터-시스템의-동작-원리)
    1. [주요 컴퓨터 시스템의 요소](#주요-컴푸터-시스템의-요소)
    2. [Memory address section](#Memory-address-section)
    3. [Interrupt Handling](#interrupt-Handling)
    4. [I/O Structure](#IO-Structure)
    5. [I/O 처리 단계](#IO-처리-단계)
    6. [Storage Structure](#Storage-Structure)
    7. [Memory, CPU Protection](#memory-and-CPU-Protection)
04. [인터럽트의 원리](#인터럽트의-원리)
    1. [인터럽트와 관련된 지식](#인터럽트와-관련된-지식)
    2. [인터럽트 종류](#인터럽트-종류)
    3. [프로세스의 실행 원리](#프로세스의-실행-원리)
    4. [프로세스의 상태](#프로세스의-상태)
05. [프로세스 관리](#프로세스-관리)
    1. [프로세스 문맥](#Process-Context)
    2. [Context Switch](#Context-Switch)
    3. [스케쥴러 종류](#scheduler-종류)
    4. [프로세스 생성](#프로세스-생성)
    5. [프로세스 통신](#프로세스-통신)

## 컴퓨터와 정보 기술의 역사

### 컴퓨터의 선사 시대 
<hr/>

#### _이론적 측면의 컴퓨터 역사_
컴퓨터는 다양한 정보들을 숫자 형태로 매핑이 가능한 점에서, 컴퓨터의 이론적인 임무는 숫자의 표현과 처리 방식 두가지이다.

이러한 측면에서 고대 그리스와 로마의 숫자 시스템에 컴퓨터의 이론적 기원이 있으며, 논리학적 측면에서는 소크라테스의 연역법등이 존재한다.

그 뒤, 1930년대 학자 알론조 처치, 앨런 튜링, 쿠르트 괴델, 안드레이 마르코프등에 의해 명확한 수학적인 모델로 표현하는 방법과 알고리즘을 기술하는 추상적 모델을 설계하였다.

튜링 머신은 메모리나 기계적 동작이 실제 존재하는 기계가 아니라 가상적이고 논리적인 기계쪽이 더 정확하며 현대 컴퓨터가 풀 수 있는 모든 문제는 튜링 머신에서도 풀 수 있다.
또한, 튜링 머신의 정지 문제같이 튜링 머신에서 풀 수 없는 문제는 현대 컴퓨터에서도 풀 수 가 없다.

즉, 시대가 변해도 컴퓨터의 커다란 구조는 바뀌지 않는다.

#### _기계식 컴퓨터의 역사_
17세기
- 고트프리드 라이프니츠 - 파스칼 계산기를 개량해 사칙 연산을 자동적으로 수행하는 기계식 계산기 
- 파스칼 - 톱니바퀴를 이용한 덧셈 뺄셈의 계산기

19세기 <br><br>
배비지의 해석기관 <br> 
 - 프로그램이 가능한 최초의 기계식 컴퓨터
 - 천공 카드로 프로그램하여 연산을 정확하게 자동으로 수행<br>
- 현대 컴퓨터의 구성요소 입력, 출력, 처리, 저장장치를 포함함
- 컴퓨터의 수요가 적은 상태에서 지속적인 개발 비용이 발생해 현실화하지 못함

#### _전자식 컴퓨터의 역사_
기계식 계산기는 톱니바퀴같은 순수한 기계 장치로 동작하는 한편 전자식 계산기는 전자 장치로 동작하는 컴퓨터

- 콘라트 추제의 컴퓨터: yes-no방식으로 프로그래밍이 가능한 이진 체계의 디지털 컴퓨터
- 콜로서스: 튜링이 독일군의 암호를 풀기 위해 개발한 세계 최초의 전자식 컴퓨터
- ABC컴퓨터:  미분 방정식을 풀 수 있는 컴퓨터
- Mark-I: 하워드 에이컨 교수가 IBM의 지원으로 ABC컴퓨터를 이용해 만든 거대한 컴퓨터
- ENIAC: 제2차 세계대전 중 탄도 거리를 정확히 계산하기 위해 개발 시작한 컴퓨터<br>
    - 계산 속도는 이전 컴퓨터보다 500배빠르지만 잦은 오류가 잔재 
    - 전쟁이 끝나서 개발이 중단되었지만, 컴퓨터가 상업적으로 사용될 수 있는 확신을 갖게해 최초의 현대적 컴퓨터로 인식됨

### 근대 컴퓨터
<hr/>
1940년대 부터 하드웨어 기술 발전을 토대로 1~4세대로 분류한다.

1. __1세대__ 진공관 기반 컴퓨터<br>
진공관은 전구 크기의 유리관으로 구성되며 스위칭 회로를 내장하고 있어 가격과 부피가 컸다<br>
ENIAC이 진공관 기반의 1세대 컴퓨터에 속해있다.

2. __2세대__ 트랜지스터 기반 컴퓨터<br>
1948년, 미국의 벨 연구소에서 전기 신호의 증폭 작용을 적용한 반도체 트랜지스터를 개발하였다.
덕분에 부피가 작아지고 가격이 저렴해진 2세대 컴퓨터가 등장하기 시작하였다.<br>
기기의 신뢰성이 높아지고 소프트웨어 발전이 이루어져 컴퓨터에서의 프로그래밍 작업의 사람 중심 언어 필요성이 대두되며 컴퓨터의 관리를 자체적으로 처리하길 원했다.<br>
-> 어셉블리어와 고급 언어 포트란이 등장하게 되었다.<br>
-> 구조적 프로그래밍 기법이 등장하였다.<br>
-> OS가 개발되기 시작했다.

3. __3세대__ 집적회로 컴퓨터 <br>
수천개의 트랜지스터를 하나의 실리콘 칩에 통합하는 기술인 집적회로가 등장하였고 그 결과
    1. 신뢰성 향상: 칩이 제작 단계에서 엄격한 테스트 결과를 거쳐 연산 결과의 신뢰성이 크게 높아짐
    2. 소형화: 컴퓨터의 부피 감소, 속도 및 전력 소모, 발열이 크게 개선

- 무어의 법칙: 고든 무어가 20년동안 1.5년마다 실리콘 칩 능력이 2배씩 발전할 것이라고 예측함
- C언어가 개발되고 UNIX운영체제의 개발과 관련되어 주목을 받기 시작
- 컴파일러가 에디터와 디버거와 통합

4. __4세대__ (V)LSI 컴퓨터<br>
- 집적 회로를 VLSI(초고밀도 집적회로)기술로 발전시킨 마이크로프로세서가 등장 -> 개인용 컴퓨터의 보급
- 객체 지향 언어의 사용 -> 신뢰성과 재사용성의 소프트웨어 개발
- 인공 지능 영역과 접목해 전문가 시스템의 연구 성행
- 윈도우 운영체제 출현, WWW, Java의 등장

### 현대 컴퓨터 
<hr/>

- 슈퍼 컴퓨터: 메인 프레임 컴퓨터보다 처리 능력이 뛰어난 상황에서 사용됨(기상 예측, 통신망 설계, 석유 탐사)
- 메인 프레임 컴퓨터: 터미널을 통해 접속하여 사용함
시분할 방식을 사용해 전국의 여러 서비스 지점의 터미널과 동시에 서비스가 가능함<br>
시분할 방식: 컴퓨터 처리 능력을 짧은 시간 단위로 구분하여 사용자들에게 조금씩 분할해 주는 방식
- 개인용 컴퓨터: 워크 스테이션의 소형화, 데스크탑의 고성능화 때문에 둘의 격차가 묘해짐<br>
서버란 네트워크로 연결된 다른 컴퓨터에게 서비스를 제공하는 소프트웨어로, 서버급 컴퓨터는 워크스테이션 이상을 가리킨다.
- 휴대용 컴퓨터: 랩탑, PMP, PDA, SmartPhone
- 임베디드 컴퓨터: 기존의 범용 컴퓨터가 아닌 특수한 목적을 가지고 제작되는 컴퓨터<br>
범용 컴퓨터와 구조는 유사하나, 프로그램의 수정이 빈번하지 않아 프로그램이 칩 내부에 구워져 있음


## 운영 체제 개요
### _운영 체제란?_
<hr>

- 하드웨어 바로 윗단에 설치된 소프트웨어로 사용자 소프트웨어와 하드웨어간의 중재자 역할을 한다.
- 운영 체제없이 하드웨어를 사용할 수 없어, 부팅 시 운영체제의 load는 필수적이다.
- 항상 쓰이지 않는 유틸리티들은 보조 기억장치에 두는데 프로그램 성격을 띄지만 운영 체제와 함께 설치되고 시스템을 위해 쓰이기 때문에 넓은 의미로 운영체제로 본다. 

운영 체제는 한정된 메모리에 모두 올리기 부담스럽게 커서 필요한 부분만 메모리에 존재하고 필요 없는것들은 보조 기억장치에 저장된다.<br>
__Kernel__: 메모리에 상주하는 운영 체제 부분

<br>

### _운영 체제의 역할_
<hr/>

- 편리한 환경 제공: 하드웨어 관리 같은 어려운 작업들을 사용자 대신 처리<br>사용자들이나 프로그램들이 각자 독자적으로 사용되고 있는것 같이 느끼게 해줌
- 자원 관리자: 시스템내의 자원을 효율적으로 관리하여 성능향상에 힘씀<br>
효율성도 중요하지만 형평성 또한 고려해야 한다.
- 보안 및 보호: 사용자의 잘못된 사용으로 인한 오류 방지<br>
악의성 프로그램에 의한 간섭 방지

<br>

### _운영 체제의 분류_
<hr/>

- Multi Tasking의 지원 유무
1. Single Tasking OS: 한 번에 하나의 프로그램만 수행 가능<br>
ex) 초기 컴퓨터, MS-DOS
2. Multi Tasking OS: 하나의 프로그램의 수행이 끝나기 전에 다른 프로그램의 수행이 가능<br>
ex) MS윈도우, 유닉스

다중 프로그래밍의 조건: 
1. Time sharing System: 프로그램의 다중 수행을 위해 CPU의 자원마다의 할당을 시간단위로 줌
2. Interactive System: 각 프로그램들이 하나하나에 대한 입출력을 대화를 하듯이 바로바로 보여줌<br>
Time sharing System의 단위 시간이 짧아 가능하다.
3. Multi Programming System: 메모리 공간을 분할해 동시에 메모리에 올려놓음

Multi Processor System: 하나의 컴퓨터안에 여러개의 CPU가 설치된 시스템<br>
연산을 한 번에 여러개를 수행할 수 있지만 CPU관리를 위한 복잡한 매커니즘이 필요<br>
Multi Programming의 조건과는 별개의 시스템임

<br>

- Multi User의 지원 유무
1. Single User OS: 한 번에 한 명의 사용자만 접근하게 하는 운영 체제

    - DOS같이 Single Tasking OS인 경우
    - MS Windows같이 한 명의 사용자가 Multi Tasking을 하는 경우(NT제외)
2. Multi User OS: 서버처럼 다수의 사용자가 접근할 수 있게 쓰이는 운영 체제 

<br>

- 작업 처리 방식
1. Batch Processing OS: 작업 요청을 일정량 모아 한번에 처리하는 방식
2. Time Sharing OS: 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식 -> 대화형 시스템으로 가는 길
3. Real Time OS: 정해진 데드라인까지 처리해야 하는 일이 종료되어야 하는 시스템
    - Hard Realtime System: 원자로, 미사일시스템 같이 데드라인을 무조건 지키게 해야하는 시스템
    - Soft Realtime System: 스트리밍같이 데드라인을 지키면 원활한 서비스가 되는 형식의 시스템

Plug and Play: MS Windows처럼 새로운 하드웨어를 장착하면 OS에서 감지하여 그에 맞는 설정을 해주는 것

<br>

### _운영 체제의 자원 관리 기능_
<hr/>

- CPU Scheduling: CPU를 효율적, 공정성있게 자원을 처리하는 방식
    1. FCFS: 선입선출, 먼저 요청한 작업을 먼저 끝낸다.<br>
    금방 끝날 작업들이 작업 시간이 긴 작업들에 의해 지연되는 현상이 발생
    2. Round Robin: 일정 시간 작업을 수행해도 끝나지 않으면 대기 목록의 끝으로 미루어둠
    3. Priority: 대기중인 프로세스들에게 우선순위를 부여해, 차등으로 CPU를 할당함<br>
    대기 시간이 길어지는 작업의 우선순위를 순차적으로 높이면서 공정성을 해결할 수 있음
- Memory Management: 한정된 메모리를 효율적으로 사용하기 위한 매커니즘
    - 메모리에 주소체계를 사용해 각 부분에서 무슨 프로그램이 사용되는지 알 수 있게 관리
    - Multi User System경우 각 사용자의 프로세스 영역을 침범하지 않게 보안을 유지

- I/O Device Management:
    - 각 Device에 작은 CPU를 가진 Controller가 Device의 작업을 수행
    - 작업이 끝나면 CPU에게 Interrupt를 검
    - CPU는 하던일을 멈추고 운영체제가 작업 상태를 저장
    - 요청 받은 Interrupt에 해당되는 Interrupt Service를 수행 - 저장한 작업 상태를 불러와 하던 작업을 재개함
    - 운영 체제는 인터럽트마다 처리해야 하는 인터럽트 처리 루틴을 Kernel안에 프로그램 코드로 가지고 있음

Physical Memory Management Method
1. Fixed Partition:
    - 물리적 메모리를 영구적으로 분할함, 각 분할 크기는 변경이 되지 않음
    - 사용 가능한 분할 영역 중 가장 큰 영역보다 큰 프로그램은 적재하지 못함
    - Internal/External Fragmentation이 발생할 수 있음
2. Variable Partition: 
    - 매 시점마다 프로그램의 크기에 맞게 메모리를 분할해 사용하는 방식
    - External Fragmentation만 발생할 수 있음
3. Virtual Memory: 
    - 물리 메모리보다 큰 프로그램을 수행할 수 있음
    - 아무리 큰 프로그램이라도 한 번에 모든 영역이 물리 메모리에 적재되지 않는 것을 이용
    - 필요한 것만 물리 메모리에 적재시키고 사용 대기중인 것들을 보조 기억 장치의 Swap Area에 저장해둔다.
    - 가상 메모리는 실제 메모리와 별개로 자신만의 주소로 0부터 가짐
    - 가상 메모리의 주소를 물리 메모리의 주소와 매핑하는 기술로 주소를 변환시킴

<br>

## 컴퓨터 시스템의 동작 원리
### 주요 컴퓨터 시스템의 요소
<hr/>

Controller
- I/O를 CPU연산과 동시에 수행하기 위해 작은 CPU가 각각 내장되어있다.
- Main Memory와 I/O는 동시에 수행이 가능하며, Main Memory참조는 CPU만이 할 수 있다
- 따라서, Controller는 Device가 주어진 연산이 끝나면 CPU에게 인터럽트를 주어 주어진 인터럽트 벡터 루틴을 통해 I/O데이터를 Main Memory에 참조할 수 있게 한다.
- Device 혹은 Main Memory의 데이터를 임시로 저장할 수 있는 local Buffer를 가지고 있다.

CPU
- 옆에 Interrupt Line을 두어 Interrupt Signal이 들어오는지 파악
- CPU는 명령 하나를 수행할 때마다, 인터럽트를 체크한다.

Kernel: 
- 운영 체제의 일부분이 항상 메모리에 상주하는 것
- 인터럽트 처리 루틴: 다양한 인터럽트에 대한 처리 업무를 정의 한다.<br>
인터럽트 처리 루틴은 운영 체제의 개발자가 미리 프로그래밍하여 커널 내에 포함시켜 둔다.
- OS가 인터럽트의 대응 루틴을 쉽게 찾기 위해 Interrupt Vector를 갖는다
- Interrupt Vector: 인터럽트 종류마다, 번호를 정해 번호에 따라 처리할 코드(Interrupt Service Routine)의 포인터를 가진 자료구조
- Kernel mode, User mode 두 가지의 Operation mode가 존재해 중요한 명령 및 연산을 Kernel mode로 운영 체제에게 맡긴다.
- 사용자 프로그램이 CPU를 가지고 있는 동안 운영 체제가 CPU를 선점할 수 없어 CPU내부에 Mode bit를 두어 0(kernel),1(user)mode를 둔다.
- 사용자 프로그램이 System Call을 사용하면 Mode bit가 0이 되어 OS에게 위임한다.

### Memory address section
<hr/>

1. Data: 프로그램의 전역 변수 저장
2. Stack: 실행 중인 함수A가 다른 함수B를 호출하면 호출 함수를 수행하는데, B의 수행이 끝나면 A로 돌아가기 위해 복귀 주소를 저장한다. <br>
A의 수행과 B의 수행은 다른 메모리 주소가 바뀐다.
3. Code: 프로그래머가 작성한 코드가 기계어 명령 형태로 저장되는 영역 <br>
CPU가 매 시점 Code영역의 명령을 하나씩 수행한다.

### Interrupt Handling
<hr/>

CPU가 명령을 수행할 때 CPU내부의 레지스터에 데이터를 읽거나 씀<br>
인터럽트가 발생해 새로운 명령을 수행하면 기존의 레지스터값들이 지워짐<br>
PCB: 
- 수행되는 프로그램들을 관리하기 위해 Kernel에서 저장되는 자료구조
- 인터럽트가 발생했을 때 레지스터 값, 메모리 주소 등 작업내용이 없어지므로 그 내용들을 저장하는 자료구조를 내포하고 있다.
- 새로 생긴 Interrupt의 서비스가 끝나고 기존 작업으로 돌아갈 때 사용된다.

Handling 내용:
- 프로그램 내부의 다른 함수호출은 작업 내용을 Stack에 저장한다.
- 인터럽트가 발생하면, 실행 중이던 작업 내용은 PCB에 저장되며 인터럽트 루틴을 수행하는 도중 발생하는 함수는 커널안의 stack영역 중 직전까지 수행했던 프로그램과 연관된 Kernel Stack이 수행함
- 인터럽트의 처리 중 호출되는 함수 또한, 이전 작업을 그 Stack에서 수행됨
- 수행중인 프로그램 수 n만큼 Stack도 n개의 독립적인 공간을 만든다.

_인터럽트 중 인터럽트가 발생할 때_

- 원칙적으로 데이터의 일관성 때문에, 허용하지 않음
- 하지만 중요도가 높은 인터럽트를 허락할 수 있다.
- 이 때, Kernel의 stack에 작업 중이던 인터럽트 작업을 저장한다.

Software Interrupt:
- 예외 사항: 프로그램이 수행하면 안되는 부분을 접근할 때 발생
- System Call: 운영 체제에 정의된 함수를 호출하는 것<br>
ex) printf라는 함수를 호출하면 그 안에 있는 write System Call을 호출해 운영 체제가 그 작업을 수행하게 시킴

### I/O Structure
<hr/>

- Synchronous I/O: 
    - 프로그램이 I/O 요청을 하면 CPU는 그 프로그램의 I/O가 끝날 때 까지 제어권을 주지 않음
    - I/O가 끝날때 까지, CPU가 그 프로그램에 상주하면 낭비이므로 다른 프로그램에게 제어권을 넘김
    - CPU가 다른 프로그램에게 양도하는 결과, 같은 Device에 I/O 요청이 두개 이상이 될 수 있으며 의도치 않는 결과가 발생한다 
    - 따라서, Device별로 queue를 두어 순서대로 I/O를 수행하게 한다.
    - I/O가 끝나면 Device Controller는 CPU에게 프로그램의 봉쇄상태를 Unlock하라고 인터럽트를 보낸다.
- Asynchronous I/O: 
    - I/O 요청 후에도 CPU제어권을 다시 그 프로그램에게 부여하는 방식
    - 해당 I/O와 상관없는 작업을 하다가, I/O작업이 끝나면 다시 그 작업을 재개한다.
- Direct Memory Access:
    - I/O 연산을 Device마다 Controller가 존재해도 모두 CPU를 거치게 되면 효율성이 떨어짐
    - 그래서 DMA라는 일종의 Controller를 두어, local Buffer에서 메모리로 읽어오는 작업을 대신해, 작업을 마친 Interrupt만을 CPU가 처리해 CPU의 효율성을 증대시킨다. 

### I/O 처리 단계
<hr/>

    1. 프로그램 A가 Device에게 입력을 하라고 CPU에게 Interrupt를 보낸다.
    2. CPU가 수행 중인 프로그램 A의 상태와 레지스터값을 PCB에 저장 후, 커널의 루틴으로 이동
    3. 처리 루틴에서 CPU는 Controller에게 I/O를 요청한다.
    4. Device는 local Buffer로 데이터를 입력을 받으면서, 프로그램 A(Asynchronous)나 차례상 다른 프로세스(Synchronous)가 CPU의 제어권을 얻는다.
    5. 데이터를 모두 입력 받으면, Controller는 CPU에게 Interrupt를 주어 처리를 한다.
    6. 인터럽트를 처리하기 전에 현재 프로그램 상태를 저장한다.

### Storage Structure
<hr/>

- 주 기억 장치 & 휘발성 메모리:
    1. Register: CPU내부에 존재하며, CPU작업 내용들을 저장한다.
    2. Cache Memory: Register와 Main Memory사이에 존재하며, 캐슁 기법으로 빈번히 사용되는 정보를 선별적으로 저장함<br>
    용량이 적고 빠른 저장 장치의 성능 향상을 위한 캐싱 기법 사용
    3. Main Memory: 실행할 프로그램 및 시스템을 유지할 운영 체제 Kernel, 시스템 영역이 올라감
- 보조 기억 장치 & 비휘발성 메모리:
    1. File System용: 전원이 나가도 유지해야할 정보를 파일 형태로 저장
    2. Swap Area: 한정된 메모리를 효율있게 사용하기 위해 프로그램 내용을 저장하고 당장 사용할 내용들만 Main Memory로 Swap in시킨다.<br>
    필요 없는 내용들은 다시 보조 기억 장치의 Swap Area로 Swap in시킨다.

### Memory and CPU Protection
<hr/>

Memory

- 메모리 경우, 여러 프로그램이 동시에 올라가므로 다른 사용자나 프로그램이 C언어의 포인터등으로 메모리 주소를 잘못 참조하여 침범할 수 있다.
- 그래서 Base Register, Limit Register 두개를 사용해 프로그램의 메모리 범위를 명시해 다른 프로그램의 메모리를 참조하지 못하게 한다.
    - Base Register: 프로그램의 시작 주소
    - Limit Register: 프로그램이 사용할 수 있는 메모리 공간
    - 이 경우 Page기법을 사용한 경우 일반적으로 보호가 보장되지 않는다
- Memory연산은 사용자 프로그램에서도 사용이 가능하지만, Base와 Limit Register값 세팅은 Kernel Mode에서 이루어져야 한다.

CPU
- CPU를 부적절하게 독점을 할 경우 OS가 CPU를 선점할 수가 없게 된다.
- Timer: 정해진 시간이 지나면 OS에서 CPU 제어권을 다른 프로그램으로 양도 시킨다.
- Timer가 지나면 인터럽트를 보내어 CPU제어권을 바꾸게 한다.
- 시분할 시스템에서 현재 시간을 계산하기 위해서도 사용한다
- Load Timer: 타이머 값을 세팅하는 명령, Kernel Mode에서 수행되어야 한다.


## 인터럽트의 원리

### 인터럽트와 관련된 지식
<hr/>

함수의 호출: 함수 코드가 실행되다가 내부의 다른 함수를 호출하면, 현재 실행되었던 코드의 주소와 데이터를 stack에 넣고 다른 메모리 주소에 존재하는 호출 함수로 점프한다.<br>

인터럽트의 동작 원리도 함수의 호출과 비슷하다.
1. 실행 중인 프로그램A가 인터럽트가 발생하면 수행중인 명령 위치를 PCB에 저장
2. 커널의 인터럽트 처리 루틴으로 가서 인터럽트를 처리한다.
3. 처리 완료 후 프로그램A의 상태를 PCB에서 복구한다.
<br>

프로그램 카운터: CPU가 가리키는 다음에 실행할 코드의 포인터
- 조건문, 반복문, 함수 호출등의 주소 이동이 없으면 PC는 다음 주소의 명령을 가리킴

### 인터럽트 종류
<hr/>

1. System Call:
    - 프로그램이 운영 체제만이 할 수 있는 일을 맡기기 위한 인터페이스
    - 사용자 정의 함수나, 라이브러리 함수에서 호출하여 커널 영역에 정의된 처리 코드를 수행, Software Interrupt의 하나의 종류
    - 예를 들어
        1. 프로그램이 디스크에서 자료를 읽어 오는 경우, CPU는 레지스터의 값으로 Disk Controller에게 데이터를 읽어 오라는 명령의 주소값으로 변경
        2. Disk Controller가 Disk의 데이터를 Local Storage에 저장
        3. Disk Controller가 CPU에게 데이터를 모두 읽었다고 인터럽트를 보냄
        4. CPU는 수행중인 프로그램을 중단하고 Disk의 데이터를 가져왔다는 인터럽트를 받아 처리하는 인터럽트 처리 루틴을 수행한다.
2. Hardware Interrupt
    - 1번의 예시-3처럼 hardware Controller가 CPU에게 보내는 인터럽트를 말한다.
    - 주변 장치가 CPU의 도움이 필요해 인터럽트 라인을 세팅하는 것이다.
    - CPU가 매번 명령을 수행한 직후 인터럽트 라인을 체크해 들어온 인터럽트가 있는지 체크한다.
3. Exception: 프로그램이 허용하지 않는 연산을 수행하려고 했을 때 조치를 해주는 인터페이스
### 프로세스의 실행 원리
<hr/>

프로세스마다 Data, Stack, Code영역을 각각 가지고 있고 필요한 것만 Physical Memory에 올라가고 대기 중인 내용들은 Disk내 Swap Area에 존재하고 별도의 Virtual Memory로 관리된다.<br>

운영 체제도 하나의 프로세스로 간주하여 커널안에 Data, Stack, Code주소 공간 구성을 갖는다.<br>

Kernel의 Code: CPU, Memory같은 자원 관리를 위한 logic이 존재<br>
Kernel의 Data: PCB같이 현재 수행중인 프로그램을 관리하기 위한 자료 구조가 있음    
- 프로세스 상태 관리를 위한 Queue들도 존재

Kernel의 Stack: 수행 중인 프로세스마다 스택이 존재<br>
- 프로그램이 시스템 콜을 호출해 커널 영역 코드를 실행하고 사용자 프로그램으로 돌아가기 위해 각각 프로세스마다 stack을 따로 둠
- 시스템 콜내부의 함수를 호출하고 사용하기 위함도 있다.

### 프로세스의 상태
<hr/>

1. Ready State: CPU를 할당 받으면 바로 명령을 수행할 수 있는 상태<br>
- Ready Queue의 순서 세팅법은 CPU 스케줄링 방법마다 다름
2. Wait State: I/O작업 등으로 CPU가 할당하려 해도 명령을 수행할 수 없는 상태
- 자원별로 Queue를 가지고 있음(디스크 I/O 요청한 작업은 Disk Queue에 쌓임)
- 해당 Queue에서 Pop하고 I/O를 마친 작업은 Controller가 CPU에게 인터럽트를 보내고 인터럽트 루틴을 처리하는 도중 해당 작업은 Ready Queue로 이동한다.
3. Running State: CPU를 할당받은 상태
- 프로세스A가 실행 도중 System Call을 호출해도 운영 체제가 Running State인 것이 아닌 프로세스A가 Running State라는 것이 변하지 않는다.
- 프로세스A가 실행 중일 때, 프로세스B의 I/O완료로 인한 Hardware Interrupt가 와도 문맥 상 프로세스A가 실행 중 Kernel모드로 진입한 것이라고 본다.
4. New State: 프로세스를 위한 자료구조가 생성되었으나 아직 메모리 획득을 승인 받지 못한 상태
5. Terminated State: 프로세스가 종료되었으나 OS가 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

OS는 각각 상태마다 실행 순서를 위한 큐를 가지고 있다.<br>
이렇게 하드웨어 자원을 기다리는 프로세스를 위한 큐도 존재하지만 공유 데이터 접근을 위해 소프트웨어 자원을 처리할 Queue도 같은 원리로 존재<br>


## 프로세스 관리

### Process Context
<hr/>

Process Context: 프로세스가 현재 어떤 상태에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보<br>

CPU는 시분할 시스템 환경에서 타이머 인터럽트로 다른 프로세스에게 제어권을 넘겨줘야 하기 때문에 프로세스의 주소공간(Code, Data, Stack)과 레지스터 값, 커널에 수행되어온 일의 상태, 커널이 관리하고 있는 정보(PCB)를 포함해 저장해둘 필요가 있다.

Context의 종류
1. Hardware Context: CPU수행 상태를 나타낸 것, PC값과 각 종 레지스터의 저장값을 의미
2. Process address space: 프로세스만의 독자적인 주소공간
3. Kernel Context: PCB와 커널 스택

__PCB__
: OS가 시스템 내에서 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널내의 자료구조
1. 프로세스 상태: CPU할당 가능 여부
2. Program Counter값: 다음에 수행할 명령의 위치
3. CPU Register값: 현 시점에서 레지스터에 저장되어 있는 값
4. CPU Scheduling Information
5. Memory Management Information
6. Resource Usage Information: 사용자에게 자원 사용율을 계산해 알려주는 용도
7. I/O 상태 정보

### Context Switch
<hr/>

Context Switch: 실행할 프로세스를 변경하기 위해 수행 중이던 프로세스의 문맥을 저장하고 새로운 프로세스의 문맥을 세팅하는 과정

CPU Dispatch: Ready상태 프로세스들 중 CPU를 할당 받을 프로세스를 선택 후 CPU제어권을 넘겨받는 과정

__프로세스가 I/O 요청을 하는 경우__
1. I/O 요청을 한 프로세스가 실행 상태에서 Wait상태가 된다.
2. CPU를 반환하고 디스크 I/O 서비스를 기다리는 Device queue에 추가된다.
3. 다른 Ready상태의 프로세스가 CPU Dispatch된다.
4. Device queue에서 자기 차례가 되어 I/O서비스를 하거나 받아 Controller가 CPU에게 인터럽트를 발생 시킴
5. 인터럽트를 인지한 CPU는 커널모드로 인터럽트 루틴을 실행하면서 Device queue에서 Ready queue로 빼낸다.
6. 프로세스 상태를 Ready로 바꾸어 주고 로컬 버퍼의 내용을 메모리로 이동시킴
7. 다시 CPU가 사용자 모드가 되고, 인터럽트 루틴을 실행하기 전에 수행했던 프로세스나 방금 Ready queue에 들어간 프로세스 중 우선 순위가 높은 프로세스에게 CPU제어권이 돌아간다 -> 스케쥴링마다 다름

Context Switch란 다른 프로세스로 CPU제어권이 이양되는 과정이지만 프로세스가 System call이나 인터럽트 발생으로 OS커널의 코드를 실행하는 과정 속에서 Process Context일부를 PCB에 저장하지만 Context Switch라고 부르지 않음<br>
-> 하나의 프로세스가 사용자 모드에서 커널 모드로 바뀌는 것일뿐 CPU를 점유하는 프로세스 대상이 바뀌는게 아니기 때문이다.

Context Switch는 많은 Overhead가 따른다. 따라서 타이머에 CPU할당시간을 너무 작게 세팅하면 좋지 않다.

### Scheduler 종류
<hr/>

Scheduler: 어떤 프로세스에게 자원을 할당할지 결정하는 OS커널의 모듈

Long Term Scheduler(장기 스케줄러)<br>
- Job Scheduler라고도 함
- 어떤 프로세스를 Ready queue에 넣을지 결정함
- 프로세스에게 메모리를 할당하는 문제를 관여하며 메모리에 동시에 올라간 프로세스의 수를 조절한다.
- New상태의 프로세스를 Ready상태로 만들지도 관여함
- 가끔 호출되기 때문에, 속도가 느린것이 허용된다.
- 시분할 시스템을 사용하는 근래 OS엔 사용하지 않는게 대부분이다.

Short Term Scheduler(단기 스케줄러)<br>
- Ready프로세스 중 어떤 프로세스를 실행 상태로 만들지 결정한다.
- 시분할 시스템에서 타이머 인터럽트가 발생하면 단기 스케줄러가 호출됨
- 빈번하게 호출되기 때문에 수행속도가 빨라야 한다.

Medium Term Scheduler<br>
- 메모리 용량이 많아진 현대에는 장기 스케줄러를 사용하지 않는다.
- 많은 프로세스가 메모리를 할당할 경우 시스템 성능 저하를 해결하기 위해 메모리에 적재된 프로세스 수를 동적으로 조절한다.
- 일부 프로세스를 메모리에서 디스크로 Swaqp out하는 역할을 한다.
- Swap out의 0순위 프로세스는 Wait상태의 프로세스들이다 -> 당장 cpu를 획득할 가능성이 없기 때문
- 그래도 공간이 부족할 경우 타이머 인터럽트가 발생해 Ready queue로 이동한 프로세스를 추가적으로 시행한다.
- 이 스케줄러 덕분에 Stopped이라는 프로세스 상태가 추가됨 -> 프로세스를 외부에서 재개하지 않는 이상 다시 활성화 될 수 없음
- 이 스케줄러로 디스크에 Swap out된 프로세스 상태는 Stopped이 된다.

### 프로세스 생성
<hr/>

자식 프로세스의 자원 획득법:
1. OS에게 직접 할당 받음
2. 부모 프로세스에게 자원을 공유 받음

부모 프로세스의 종류:
1. 자식 프로세스와 공존하면서 CPU획득을 경쟁한다.
2. 자식 프로세스가 종료될때까지 부모 프로세스가 Wait상태로 존재한다.
ex) D-Dos에서 커맨들들 입력하면 종료할 때 까지 프롬프트를 다시 띄우지 않는다.

프로세스의 생성
- 유닉스의 Folk System Call은 PID를 제외한 커널내의 정보와 주소 공간 정보를 그대로 복사한다.
- 주소 공간을 따로 갖지만 동일한 내용을 가지고 시작하며, exec 시스템콜로 새로운 프로그램으로 주소 공간을 덮어 쓸 수 있다.

프로세스의 종료 방법:
1. 자발적 종료: 
    - 프로세스가 마지막 명령을 수행한 뒤 OS에게 알리는 것
    - exit() System Call로 종료를 알림 -> OS가 자원을 회수하고 시스템 내에서 프로세스를 정리한다.
    - exit함수를 명시적으로 호출하지 않아도 컴파일러가 자동으로 삽입해 종료직전에 호출한다.

2. 비자발적 종료: 부모 프로세스가 자식 프로세스 수행을 강제로 종료 시킴, abort() 시스템콜 사용<br>
<필요한 시기>
    - 자식 프로세스가 할당 자원의 한계치를 넘는 경우
    - 자식 프로세스의 작업이 필요없을 때
    - 부모 프로세스가 종료되고 싶을 때

### 프로세스 통신
<hr/>

부모-자식 프로세스의 상호 소통
- folk함수의 반환값으로 부모 프로세스는 자식 프로세스의 PID를 받고 자식 프로세스는 0을 받는다.
- 자식 프로세스를 생성하면 사실상 부모 프로세스와는 독립적인 관계가 된다.
- 하지만 독립적인 프로세스들이 서로 협력을 해 처리 속도를 향상 시킬 수 있게 OS에서 프로세스간 협력 매커니즘 IPC를 제공한다.
- IPC를 사용할 때 데이터의 불 일치를 막기 위해 프로세스간의 동기화가 필요하다.

IPC: inter Process Communication<br>
공유 변수를 사용하냐 마냐 차이로 두가지로 분류된다.
1. Message Passing: 
    - 프로세스간 공유 변수를 사용하지 않고 메세지를 주고 받는 형식
    - 두 프로세스간 주소 공간이 달라 커널이 대신 전달해줌

    전송 대상에 따라 두가지로 나뉨
    - Direct Communication: 
        - 다른 프로세스에게 직접 메세지가 전송됨
        - 상대 프로세스의 이름을 명시적으로 표현함
        - send(P, Message), receive(Q, Message)
        - 이 때, 통신 링크는 자동적으로 생성되며 하나의 링크는 한 쌍마다 할당
    - Indirect Communication:
        - 메일 박스라는 저장 공간에 메세지를 전송함
        - 메세지를 Mail box나 Port로부터 전달 받음
        - Mail box마다 고유의 ID를 가짐
        - 하나의 링크가 여러 프로세스들에게 할당될 수 있다.
        - send(A, Message), receive(A, Message)처럼 대상을 mail box이름을 한다.
    
    Direct, Indirect는 연산의 인터페이스가 차이날 뿐, 내부적인 구현 방식은 커널의 중재에 의해 사실상 동일한 방식

2. Shared Memory: 
    - 프로세스들이 주소 공간 일부를 공유한다.
    - OS가 제공하는 공유 메모리 System Call을 사용해 주소 공간 중 일부를 공유한다.
    - 데이터 일관성을 커널이 책임지지 않기에 프로세스들끼리 직접 공유 메모리 접근에 대한 동기화 문제를 책임져야 한다.

