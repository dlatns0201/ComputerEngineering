# 운영 체제 개요

1. [운영 체제란](#운영-체제란)
2. [운영 체제의 역할](#운영-체제의-역할)
3. [운영 체제의 분류](#운영-체제의-분류)
4. [운영 체제의 자원 관리 기능](#운영-체제의-자원-관리-기능)

## 운영 체제란

- 하드웨어 바로 윗단에 설치된 소프트웨어로 사용자 소프트웨어와 하드웨어간의 중재자 역할을 한다.
- 운영 체제없이 하드웨어를 사용할 수 없어, 부팅 시 운영체제의 load는 필수적이다.
- 항상 쓰이지 않는 유틸리티들은 보조 기억장치에 두는데 프로그램 성격을 띄지만 운영 체제와 함께 설치되고 시스템을 위해 쓰이기 때문에 넓은 의미로 운영체제로 본다. 

운영 체제는 한정된 메모리에 모두 올리기 부담스럽게 커서 필요한 부분만 메모리에 존재하고 필요 없는것들은 보조 기억장치에 저장된다.<br>
`Kernel`: 메모리에 상주하는 운영 체제 부분


## 운영 체제의 역할

- 편리한 환경 제공
    - 하드웨어 관리 같은 어려운 작업들을 사용자 대신 처리사용자들이나 프로그램들이 각자 독자적으로 사용되고 있는것 같이 느끼게 해줌
- 자원 관리자
    - 시스템내의 자원을 효율적으로 관리하여 성능향상에 힘씀
    - 효율성도 중요하지만 형평성 또한 고려해야 한다.
- 보안 및 보호
    - 사용자의 잘못된 사용으로 인한 오류 방지
    - 악의성 프로그램에 의한 간섭 방지


## 운영 체제의 분류

### 1. Multi Tasking의 지원 유무
1. Single Tasking OS
- 한 번에 하나의 프로그램만 수행 가능
- ex) 초기 컴퓨터, MS-DOS
2. Multi Tasking OS
- 하나의 프로그램의 수행이 끝나기 전에 다른 프로그램의 수행이 가능
- ex) MS윈도우, 유닉스

#### 다중 프로그래밍의 조건: 
1. Time sharing System
- 프로그램의 다중 수행을 위해 CPU의 자원마다의 할당을 시간단위로 줌
2. Interactive System
- 각 프로그램들이 하나하나에 대한 입출력을 대화를 하듯이 바로바로 보여줌
- Time sharing System의 단위 시간이 짧아 가능하다.
3. Multi Programming System
- 메모리 공간을 분할해 동시에 메모리에 올려놓음

- Multi Processor System: 하나의 컴퓨터안에 여러개의 CPU가 설치된 시스템
- 연산을 한 번에 여러개를 수행할 수 있지만 CPU관리를 위한 복잡한 매커니즘이 필요
- Multi Programming의 조건과는 별개의 시스템임


### 2. Multi User의 지원 유무
1. Single User OS
    - 한 번에 한 명의 사용자만 접근하게 하는 운영 체제
    - DOS같이 Single Tasking OS인 경우
    - MS Windows같이 한 명의 사용자가 Multi Tasking을 하는 경우(NT제외)
2. Multi User OS
    - 서버처럼 다수의 사용자가 접근할 수 있게 쓰이는 운영 체제 

### 3. 작업 처리 방식
1. Batch Processing OS
    - 작업 요청을 일정량 모아 한번에 처리하는 방식
2. Time Sharing OS
    - 컴퓨터의 처리 능력을 일정한 시간 단위로 분할해 사용하는 방식 -> 대화형 시스템으로 가는 길
3. Real Time OS
    - 정해진 데드라인까지 처리해야 하는 일이 종료되어야 하는 시스템
    - Hard Realtime System: 원자로, 미사일시스템 같이 데드라인을 무조건 지키게 해야하는 시스템
    - Soft Realtime System: 스트리밍같이 데드라인을 지키면 원활한 서비스가 되는 형식의 시스템

Plug and Play: MS Windows처럼 새로운 하드웨어를 장착하면 OS에서 감지하여 그에 맞는 설정을 해주는 것

## 운영 체제의 자원 관리 기능
### CPU Scheduling: CPU를 효율적, 공정성있게 자원을 처리하는 방식
1. FCFS:
    - 선입선출, 먼저 요청한 작업을 먼저 끝낸다.
    - 금방 끝날 작업들이 작업 시간이 긴 작업들에 의해 지연되는 현상이 발생
2. Round Robin
    - 일정 시간 작업을 수행해도 끝나지 않으면 대기 목록의 끝으로 미루어둠
3. Priority
    - 대기중인 프로세스들에게 우선순위를 부여해, 차등으로 CPU를 할당함
    - 대기 시간이 길어지는 작업의 우선순위를 순차적으로 높이면서 공정성을 해결할 수 있음

### Memory Management: 한정된 메모리를 효율적으로 사용하기 위한 매커니즘
- 메모리에 주소체계를 사용해 각 부분에서 무슨 프로그램이 사용되는지 알 수 있게 관리
- Multi User System경우 각 사용자의 프로세스 영역을 침범하지 않게 보안을 유지

### I/O Device Management:
- 각 Device에 작은 CPU를 가진 Controller가 Device의 작업을 수행
- 작업이 끝나면 CPU에게 Interrupt를 검
- CPU는 하던일을 멈추고 운영체제가 작업 상태를 저장
- 요청 받은 Interrupt에 해당되는 Interrupt Service를 수행 - 저장한 작업 상태를 불러와 하던 작업을 재개함
- 운영 체제는 인터럽트마다 처리해야 하는 인터럽트 처리 루틴을 Kernel안에 프로그램 코드로 가지고 있음

#### Physical Memory Management Method
1. Fixed Partition:
    - 물리적 메모리를 영구적으로 분할함, 각 분할 크기는 변경이 되지 않음
    - 사용 가능한 분할 영역 중 가장 큰 영역보다 큰 프로그램은 적재하지 못함
    - Internal/External Fragmentation이 발생할 수 있음
2. Variable Partition: 
    - 매 시점마다 프로그램의 크기에 맞게 메모리를 분할해 사용하는 방식
    - External Fragmentation만 발생할 수 있음
3. Virtual Memory: 
    - 물리 메모리보다 큰 프로그램을 수행할 수 있음
    - 아무리 큰 프로그램이라도 한 번에 모든 영역이 물리 메모리에 적재되지 않는 것을 이용
    - 필요한 것만 물리 메모리에 적재시키고 사용 대기중인 것들을 보조 기억 장치의 Swap Area에 저장해둔다.
    - 가상 메모리는 실제 메모리와 별개로 자신만의 주소로 0부터 가짐
    - 가상 메모리의 주소를 물리 메모리의 주소와 매핑하는 기술로 주소를 변환시킴