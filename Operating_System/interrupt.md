# 인터럽트

1. [인터럽트와 관련된 지식](#인터럽트의-원리)
2. [인터럽트 종류](#인터럽트-종류)
3. [프로세스의 실행 원리](#프로세스의-실행-원리)
4. [프로세스의 상태](#프로세스의-상태)

## 인터럽트의 원리
### 함수 호출
- 함수 코드가 실행되다가 내부의 다른 함수를 호출하면, 현재 실행되었던 코드의 주소와 데이터를 stack에 넣고 다른 메모리 주소에 존재하는 호출 함수로 점프한다.

### 비슷한 인터럽트의 동작 원리
인터럽트의 동작 원리도 함수의 호출과 비슷하다.

1. 실행 중인 프로그램A가 인터럽트가 발생하면 수행중인 명령 위치를 PCB에 저장
2. 커널의 인터럽트 처리 루틴으로 가서 인터럽트를 처리한다.
3. 처리 완료 후 프로그램A의 상태를 PCB에서 복구한다.

### 프로그램 카운터
- CPU가 가리키는 다음에 실행할 코드의 포인터
- 조건문, 반복문, 함수 호출등의 주소 이동이 없으면 PC는 다음 주소의 명령을 가리킴

## 인터럽트 종류

### System Call:
- 프로그램이 운영 체제만이 할 수 있는 일을 맡기기 위한 인터페이스
- 사용자 정의 함수나, 라이브러리 함수에서 호출하여 커널 영역에 정의된 처리 코드를 수행, Software Interrupt의 하나의 종류
- 예시
1. 프로그램이 디스크에서 자료를 읽어 오는 경우, CPU는 레지스터의 값으로 Disk Controller에게 데이터를 읽어 오라는 명령의 주소값으로 변경
2. Disk Controller가 Disk의 데이터를 Local Storage에 저장
3. Disk Controller가 CPU에게 데이터를 모두 읽었다고 인터럽트를 보냄
4. CPU는 수행중인 프로그램을 중단하고 Disk의 데이터를 가져왔다는 인터럽트를 받아 처리하는 인터럽트 처리 루틴을 수행한다.

### Hardware Interrupt
- 1번의 예시-3처럼 hardware Controller가 CPU에게 보내는 인터럽트를 말한다.
- 주변 장치가 CPU의 도움이 필요해 인터럽트 라인을 세팅하는 것이다.
- CPU가 매번 명령을 수행한 직후 인터럽트 라인을 체크해 들어온 인터럽트가 있는지 체크한다.

### Exception
- 프로그램이 허용하지 않는 연산을 수행하려고 했을 때 조치를 해주는 인터페이스


## 프로세스의 실행 원리

- 프로세스마다 Data, Stack, Code영역을 각각 가지고 있고 필요한 것만 Physical Memory에 올라간다.
- 대기 중인 내용들은 Disk내 Swap Area에 존재하고 별도의 Virtual Memory로 관리된다.
- 운영 체제도 하나의 프로세스로 간주하여 커널안에 Data, Stack, Code주소 공간 구성을 갖는다.

### Kernel내의 구성요소
- Code: CPU, Memory같은 자원 관리를 위한 logic이 존재
- Data: PCB같이 현재 수행중인 프로그램을 관리하기 위한 자료 구조가 있음    
    - 프로세스 상태 관리를 위한 Queue들도 존재
- Stack: 수행 중인 프로세스마다 스택이 존재
    - 프로그램이 시스템 콜을 호출해 커널 영역 코드를 실행하고 사용자 프로그램으로 돌아가기 위해 각각 프로세스마다 stack을 따로 둠
    - 시스템 콜내부의 함수를 호출하고 사용하기 위함도 있다.

## 프로세스의 상태

1. Ready State: CPU를 할당 받으면 바로 명령을 수행할 수 있는 상태
- Ready Queue의 순서 세팅법은 CPU 스케줄링 방법마다 다름

2. Wait State: I/O작업 등으로 CPU가 할당하려 해도 명령을 수행할 수 없는 상태
- 자원별로 Queue를 가지고 있음(디스크 I/O 요청한 작업은 Disk Queue에 쌓임)
- 해당 Queue에서 Pop하고 I/O를 마친 작업은 Controller가 CPU에게 인터럽트를 보내고 인터럽트 루틴을 처리하는 도중 해당 작업은 Ready Queue로 이동한다.

3. Running State: CPU를 할당받은 상태
- 프로세스A가 실행 도중 System Call을 호출해도 운영 체제가 Running State인 것이 아닌 프로세스A가 Running State라는 것이 변하지 않는다.
- 프로세스A가 실행 중일 때, 프로세스B의 I/O완료로 인한 Hardware Interrupt가 와도 문맥 상 프로세스A가 실행 중 Kernel모드로 진입한 것이라고 본다.

4. New State: 프로세스를 위한 자료구조가 생성되었으나 아직 메모리 획득을 승인 받지 못한 상태
5. Terminated State: 프로세스가 종료되었으나 OS가 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태

- OS는 각각 상태마다 실행 순서를 위한 큐를 가지고 있다.
- 이렇게 하드웨어 자원을 기다리는 프로세스를 위한 큐도 존재하지만 공유 데이터 접근을 위해 소프트웨어 자원을 처리할 Queue도 같은 원리로 존재
